args:
- default: true
  description: The key to delete from the context
  name: key
- auto: PREDEFINED
  description: If you choose yes - all context will be deleted
  name: all
  predefined:
  - 'yes'
  - 'no'
- auto: PREDEFINED
  description: Specify "yes" if the context key is inside of a sub-playbook. Use **auto**
    to delete either from the sub-playbook context (if the playbook is called as a
    sub-playbook) or from the global context (if the playbook is the top playbook).
  name: subplaybook
  predefined:
  - 'yes'
  - 'no'
  - auto
- description: Context keys to keep when deleting all context. Supports comma separated
    values and nested objects, e.g. URL.Data,IP.Address
  name: keysToKeep
- description: index to delete in case 'key' argument was specified
  name: index
comment: 'Delete field from context

  This automation runs using the default Limited User role, unless you explicitly
  change the permissions.

  For more information, see the section about permissions here: https://docs.paloaltonetworks.com/cortex/cortex-xsoar/6-2/cortex-xsoar-admin/playbooks/automations.html'
commonfields:
  id: DeleteContext
  version: -1
enabled: true
fromversion: 5.0.0
name: DeleteContext
runonce: false
script: "function errorEntry(text) {\n    return  {\n        ContentsFormat: formats.text,\n\
  \        Type: entryTypes.error,\n        Contents: text\n    };\n}\n\nvar fieldsToDelete;\n\
  var shouldDeleteAll = (args.all === 'yes');\nvar isSubPlaybookKey = (args.subplaybook\
  \ === 'yes');\nif (args.subplaybook === 'auto') {\n    var res = executeCommand('Print',\
  \ { value: 'id=${currentPlaybookID}' });\n    if (res && res[0].Contents && res[0].Contents.startsWith('id='))\
  \ {\n       var idArr = res[0].Contents.split('=');\n       if (idArr.length ===\
  \ 2 && idArr[1]) {\n           isSubPlaybookKey = true;\n       }\n    }\n}\nif\
  \ (!shouldDeleteAll && !args.key) {\n    return {Contents: 'You must specify key\
  \ or all=yes',\n                    ContentsFormat: formats.text,\n            \
  \        Type: entryTypes.error};\n}\nfunction hasDuplicates(arr) {\n    return\
  \ arr.some( function(item) {\n        return arr.indexOf(item) !== arr.lastIndexOf(item);\n\
  \    });\n}\nif (shouldDeleteAll) {\n    var keysToKeep = (args.keysToKeep) ? args.keysToKeep.split(',').map(function(item)\
  \ { return item.trim(); }) : [];\n    var keysToKeepObj = {};\n    var KeepDBotScoreKey\
  \ = false;\n    index = keysToKeep.indexOf(\"DBotScore\");\n    if (index > -1)\
  \ {\n      keysToKeep.splice(index, 1);\n      KeepDBotScoreKey = true;\n    }\n\
  \    var value;\n    for (var i = 0; i < keysToKeep.length; i++) {\n        value\
  \ = dq(invContext, keysToKeep[i]);\n        if (value) {\n            if (Array.isArray(value)\
  \ && hasDuplicates(value)) {\n                setContext(keysToKeep[i], value);\n\
  \                continue;\n            }\n            keysToKeepObj[keysToKeep[i]]\
  \ = value;\n        }\n    }\n    fieldsToDelete = Object.keys(invContext);\n\n\
  \    // delete each field in context\n    var errorsStr = \"\";\n    for (var i\
  \ = 0; i < fieldsToDelete.length; i++) {\n        var key = fieldsToDelete[i];\n\
  \        if (isSubPlaybookKey) {\n            key = 'subplaybook-${currentPlaybookID}.'\
  \ + key;\n        }\n        if (key !== \"DBotScore\" || !KeepDBotScoreKey) {\n\
  \            var result = executeCommand('delContext', {key: key});\n          \
  \  if(!result || result.type === entryTypes.error) {\n                errorsStr\
  \ = errorsStr + \"\\n\" + result.Contents;\n            }\n        }\n    }\n  \
  \  var message;\n    if (errorsStr) {\n        message = \"Context cleared with\
  \ the following errors:\" + errorsStr;\n    } else {\n        message = \"Context\
  \ cleared\";\n    }\n    return {\n        Type: entryTypes.note,\n        Contents:\
  \ message,\n        ContentsFormat: formats.json,\n        HumanReadable: message,\n\
  \        ReadableContentsFormat: formats.markdown,\n        EntryContext: keysToKeepObj\n\
  \    };\n} else if (args.index !== undefined) {\n    // delete key in a specific\
  \ index\n    var index = parseInt(args.index);\n    if (isNaN(index)) {\n      \
  \  return errorEntry(\"Invalid index \" + args.index)\n    }\n    var contextVal\
  \ = invContext[args.key];\n    if (!contextVal) {\n        return \"Key [\" + args.key\
  \ + \"] was not found.\";\n    }\n    if (!Array.isArray(contextVal)) {\n      \
  \  contextVal = [contextVal];\n    }\n\n    if (index < 0 || index >= contextVal.length)\
  \ {\n        return errorEntry(\"Index out of range \" + args.index)\n    }\n\n\
  \    // splice is not supported currently\n    var newArr = [];\n    for (var i\
  \ = 0; i < contextVal.length; i++) {\n        if (i !== index) {\n            newArr.push(contextVal[i])\n\
  \        }\n    }\n\n    if (newArr.length === 0) {\n        var key = args.key;\n\
  \        if (isSubPlaybookKey) {\n          key = 'subplaybook-${currentPlaybookID}.'\
  \ + key;\n        }\n        executeCommand('delContext', { key: key });\n    }\
  \ else {\n        setContext(args.key, newArr);\n    }\n\n    return \"Successfully\
  \ deleted index \" + index + \" from key \" + args.key;\n} else {\n    var key =\
  \ args.key;\n    if (isSubPlaybookKey) {\n      key = 'subplaybook-${currentPlaybookID}.'\
  \ + key;\n    }\n    return executeCommand('delContext', {key: key});\n}\n"
scripttarget: 0
sensitive: true
tags:
- Utility
type: javascript
